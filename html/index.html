<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to PySignalHound’s documentation! &mdash; PySignalHound 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="PySignalHound 0.0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">PySignalHound 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-pysignalhound-s-documentation">
<h1>Welcome to PySignalHound&#8217;s documentation!<a class="headerlink" href="#welcome-to-pysignalhound-s-documentation" title="Permalink to this headline">¶</a></h1>
<p>Contents:</p>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<span class="target" id="module-SignalHound"></span><dl class="class">
<dt id="SignalHound.SignalHound">
<em class="property">class </em><tt class="descclassname">SignalHound.</tt><tt class="descname">SignalHound</tt><a class="reference internal" href="_modules/SignalHound.html#SignalHound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="SignalHound.SignalHound.abort">
<tt class="descname">abort</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.abort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.abort" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbAbort(int device);</p>
<p>Stops the device operation and places the device into an idle state.</p>
</dd></dl>

<dl class="attribute">
<dt id="SignalHound.SignalHound.bbStatus">
<tt class="descname">bbStatus</tt><em class="property"> = {'bbInvalidSweepTimeErr': -107, 'bbInvalidDetectorErr': -100, 'bbDeviceNotIdleErr': -10, 'bbBufferTooSmallErr': -8, 'bbNoError': 0, 'bbDeviceConnectionErr': -14, 'bbInvalidSpanErr': -102, 'bbInvalidParameterErr': -4, 'bbAllocationLimitErr': -6, 'bbDeviceAlreadyStreamingErr': -5, 'bbAttenuationErr': -104, 'bbGainNotSetErr': -11, 'bbDeviceNotStreamingErr': -2, 'bbInvalidGainErr': -105, 'bbNullPtrErr': -7, 'bbDeviceNotConfiguredErr': -3, 'bbNoTriggerFound': 3, 'bbDeviceInvalidErr': -9, 'bbInvalidBandwidthTypeErr': -108, 'bbFrequencyRangeErr': -103, 'bbDeviceNotOpenErr': -1, 'bbGPSErr': -12, 'bbAdjustedParameter': 1, 'bbInvalidVideoUnitsErr': -110, 'bbReferenceLevelErr': -111, 'bbInvalidWindowErr': -109, 'bbPacketFramingErr': -13, 'bbInvalidScaleErr': -101, 'bbADCOverflow': 2, 'bbInvalidModeErr': -112, 'bbBandwidthErr': -106}</em><a class="headerlink" href="#SignalHound.SignalHound.bbStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.closeDevice">
<tt class="descname">closeDevice</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.closeDevice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.closeDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureAcquisition">
<tt class="descname">configureAcquisition</tt><big>(</big><em>detector</em>, <em>scale</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureAcquisition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureAcquisition" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureAcquisition(int device, unsigned int detector, unsigned int scale);</p>
<dl class="docutils">
<dt>detectorType  Specifies the video detector. The two possible values for detector type</dt>
<dd>are BB_AVERAGE and BB_MIN_AND_MAX.</dd>
<dt>verticalScale  Specifies the scale in which sweep results are returned int. The four</dt>
<dd>possible values for verticalScale are BB_LOG_SCALE, BB_LIN_SCALE,
BB_LOG_FULL_SCALE, and BB_LIN_FULL_SCALE</dd>
</dl>
<p>The verticalScale parameter will change the units of returned sweeps. If BB_LOG_SCALE is provided
sweeps will be returned in amplitude unit dBm. If BB_LIN_SCALE is return, the returned units will be in
millivolts. If the full scale units are specified, no corrections are applied to the data and amplitudes are
taken directly from the full scale input.
detectorType specifies how to produce the results of the signal processing for the final sweep.
Depending on settings, potentially many overlapping FFTs will be performed on the input time domain
data to retrieve a more consistent and accurate final result. When the results overlap detectorType
chooses whether to average the results together, or maintain the minimum and maximum values. If
averaging is chosen the min and max trace arrays returned from bbFetchTrace will contain the same
averaged data</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureCenterSpan">
<tt class="descname">configureCenterSpan</tt><big>(</big><em>center</em>, <em>span</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureCenterSpan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureCenterSpan" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureCenterSpan(int device, double center, double span);</p>
<p>center  Center frequency in hertz.
span    Span in hertz</p>
<p>This function configures the operating frequency band of the broadband device. Start and stop
frequencies can be determined from the center and span.
-  start = center - (span/2)
-  stop = center+(span/2)
The values provided are used by the device during initialization and a more precise start frequency is
returned after initiation. Refer to the bbQueryTraceInfo function for more information.
Each device has a specified operational frequency range. These limits are BB#_MIN_FREQ and
BB#_MAX_FREQ. The center and span provided cannot specify a sweep outside of this range.
There is also an absolute minimum operating span.
Certain modes of operation have specific frequency range limits. Those mode dependent limits are
tested against during initialization and not here.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureDemod">
<tt class="descname">configureDemod</tt><big>(</big><em>modulationType</em>, <em>freq</em>, <em>ifBw</em>, <em>audioLowPassFreq</em>, <em>audioHighPassFreq</em>, <em>fmDeemphasis</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureDemod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureDemod" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureDemod(int device, int modulationType, double freq, float IFBW, float audioLowPassFreq, float audioHighPassFreq, float FMDeemphasis);</p>
<p>device  Handle to the device being configured.
modulationType  Specifies the demodulation scheme, possible values are</p>
<blockquote>
<div>BB_DEMOD_AM/FM/Upper sideband (USB)/Lower Sideband (LSB)/CW.</div></blockquote>
<p>freq  Center frequency. For best results, re-initiate the device if the center frequency changes +/- 8MHz from the initial value.
IFBW  Intermediate frequency bandwidth centered on freq. Filter takes place</p>
<blockquote>
<div>before demodulation. Specified in Hz. Should be between 2kHz and 500kHz.</div></blockquote>
<p>audioLowPassFreq  Post demodulation filter in Hz. Should be between 1kHz and 12kHz Hz.
audioHighPassFreq  Post demodulation filter in Hz. Should be between 20 and 1000Hz.
FMDeemphasis  Specified in micro-seconds. Should be between 1 and 100.</p>
<p>This function can be called while the device is active.
Note : If any of the boundary conditions are not met, this function will return with no error but the
values will be clamped to its boundary values</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureGain">
<tt class="descname">configureGain</tt><big>(</big><em>gain</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureGain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureGain" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureGain(int device, int gain);</p>
<p>gain            A gain setting</p>
<p>To return the device to automatically choose the best gain setting, call this function with a gain of
BB_AUTO_GAIN.
The gain choices for each device range from 0 to BB#_MAX_GAIN.
When BB_AUTO_GAIN is selected, the API uses the reference level provided in bbConfigureLevel to
choose the best gain setting for an input signal with amplitude equal to the reference level provided.
After the RF input attenuator (0-30 dB), the RF path contains an additional amplifier stage after band
filtering, which is selected for medium or high gain and bypassed for low or no gain.
Additionally, the IF has an amplifier which is bypassed only for a gain of zero.
For the highest gain settings, additional amplification in the ADC stage is used.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureIO">
<tt class="descname">configureIO</tt><big>(</big><em>port1Coupling</em>, <em>port1mode</em>, <em>port2mode</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureIO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureIO" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureIO(int device, unsigned int port1, unsigned int port2);
device  Handle to the device being configured.
port1  The first BNC port may be used to input or output a 10 MHz time base</p>
<blockquote>
<div>(AC or DC coupled), or to generate a general purpose logic high/low
output. Please refer to the example below. All possible values for this
port are found in the header file and are prefixed with “BB_PORT1”</div></blockquote>
<dl class="docutils">
<dt>port2  Port 2 is capable of accepting an external trigger or generating a logic</dt>
<dd>output. Port 2 is always DC coupled. All possible values for this port are
found in the header file and are prefixed with “BB_PORT2.”</dd>
</dl>
<p>NOTE: This function can only be called when the device is idle (not operating in any mode). To ensure
the device is idle, call bbAbort().
There are two configurable BNC connector ports available on the device. Both ports functionality are
changed with this function. For both ports, ‘0’ is the default and can be supplied through this function to
return the ports to their default values. Specifying a ‘0’ on port 1 returns the device to an internal time
base and outputs the time base AC coupled. Specifying ‘0’ on port 2 emits a DC coupled logic low.
For external 10 MHz timebases, best phase noise is achieved by using a low jitter 3.3V CMOS input.
Configure combinations</p>
<p>Port 1 IO  For port 1 only a coupled value must be ‘OR’ed
together with a port type. Use the ‘|’ operator to
combine a coupled type and a port type.</p>
<p>BB_PORT1_AC_COUPLED               Denotes an AC coupled port
BB_PORT1_DC_COUPLED               Denotes a DC coupled port
BB_PORT1_INT_REF_OUT              Output the internal 10 MHz timebase
BB_PORT1_EXT_REF_IN               Accept an external 10MHz time base
BB_PORT1_OUT_LOGIC_LOW            Self-explanitory
BB_PORT1_OUT_LOGIC_HIGH           Self-explanitory</p>
<p>Port 2 IO
BB_PORT2_OUT_LOGIC_LOW            Self-explanitory
BB_PORT2_OUT_LOGIC_HIGH           Self-explanitory
BB_PORT2_IN_TRIGGER_RISING_EDGE   When set, the device is notified of a rising edge
BB_PORT_IN_TRIGGER_FALLING_EDGE   When set, the device is notified of a falling edge</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureIQ">
<tt class="descname">configureIQ</tt><big>(</big><em>downsample</em>, <em>bandwidth</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureIQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureIQ" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureIQ(int device, int downsampleFactor, double bandwidth);</p>
<p>downsampleFactor  Specify a decimation rate for the 40MS/s IQ digital stream.
bandwidth         Specify a bandpass filter width on the IQ digital stream.</p>
<p>Downsample factor settings:
Decimation-Rate  Sample Rate (IQ pairs/s)  Maximum Bandwidth
1                40 MS/s                   27 MHz
2                20 MS/s                   17.8 MHz
4                10 MS/s                   8.0 MHz
8                5 MS/s                    3.75 MHz
16               2.5 MS/s                  2.0 MHz
32               1.25 MS/s                 1.0 MHz
64               0.625 MS/s                0.5 MHz
128              0.3125 MS/s               0.125 MHz</p>
<p>This function is used to configure the digital IQ data stream. A decimation factor and filter bandwidth
are able to be specified. The decimation rate divides the IQ sample rate directly while the bandwidth
parameter further filters the digital stream.
For each given decimation rate, a maximum bandwidth value must be supplied to account for sufficient
filter rolloff. That table is above. See  bbFetchRaw() for polling the IQ data stream</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureLevel">
<tt class="descname">configureLevel</tt><big>(</big><em>ref</em>, <em>atten</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureLevel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureLevel(int device, double ref, double atten);</p>
<p>Reference and attenuation in dBm
ref             Reference level in dBm.
atten           Attenuation setting in dB. If attenuation provided is negative,</p>
<blockquote>
<div>attenuation is selected automatically.</div></blockquote>
<p>When automatic gain is selected, the API uses the reference level provided to choose the best gain
settings for an input signal with amplitude equal to reference level. If a gain other than BB_AUTO_GAIN
is specified using bbConfigureGain, the reference level parameter is ignored.
The atten parameter controls the RF input attenuator, and is adjustable from 0 to 30 dB in 10 dB steps.
The RF attenuator is the first gain control device in the front end.
When attenuation is automatic, the attenuation and gain for each band is selected independently. When
attenuation is not automatic, a flat attenuation is set across the entire spectrum. A set attenuation may
produce a non-flat noise floor.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureProcUnits">
<tt class="descname">configureProcUnits</tt><big>(</big><em>units</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureProcUnits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureProcUnits" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureProcUnits(int device, unsigned int units);</p>
<p>device  Handle to the device being configured.
units  The possible values are BB_LOG, BB_VOLTAGE, BB_POWER, and</p>
<blockquote>
<div>BB_BYPASS.</div></blockquote>
<p>The units provided determines what unit type video processing occurs in. The chart below shows which
unit types are used for each units selection.
For “average power” measurements, BB_POWER should be selected. For cleaning up an amplitude
modulated signal, BB_VOLTAGE would be a good choice. To emulate a traditional spectrum analyzer,
select BB_LOG. To minimize processing power, select BB_BYPASS.</p>
<p>BB_LOG      = dBm
BB_VOLTAGE  = mV
BB_POWER    = mW
BB_BYPASS   = No video processing</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureRawSweep">
<tt class="descname">configureRawSweep</tt><big>(</big><em>start</em>, <em>ppf</em>, <em>steps</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureRawSweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureRawSweep" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureRawSweep(int device, int start, int ppf, int steps, int stepsize);
device  Handle to the device being configured.
start  Frequency value in MHz representing the center of the first 20MHz step</p>
<blockquote>
<div>in the sweep. Must be a multiple of 20, and no less than 20.</div></blockquote>
<dl class="docutils">
<dt>ppf  Controls the amount of digital samples to collect at each frequency</dt>
<dd>step. The number of digital samples collected at each frequency equals
18688 * ppf.</dd>
</dl>
<p>steps  Number of steps to take starting with and including the first steps.
stepsize  Value must be BB_TWENTY_MHZ</p>
<p>This function configures the device for both BB_RAW_SWEEP and BB_RAW_SWEEP_LOOP modes. This
function allows you to configure the sweep start frequency, the number of 20 MHz steps to take across
the spectrum, and how long to dwell at each frequency. There are restrictions on these settings,
outlined below.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureSweepCoupling">
<tt class="descname">configureSweepCoupling</tt><big>(</big><em>rbw</em>, <em>vbw</em>, <em>sweepTime</em>, <em>rbwType</em>, <em>rejection</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureSweepCoupling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureSweepCoupling" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureSweepCoupling(int device, double rbw, double vbw, double sweepTime, unsigned int rbwType, unsigned int rejection);</p>
<p>device  Handle to the device being configured.
rbw     Resolution bandwidth in Hz. Use the bandwidth table in the appendix to</p>
<blockquote>
<div>determine good values to choose. As of 1.07 in non-native mode, RBW
can be arbitrary. Therefore you may choose values not in the table and
they will not clamp.</div></blockquote>
<dl class="docutils">
<dt>vbw  Video bandwidth (VBW) in Hz. VBW must be less than or equal to RBW.</dt>
<dd>VBW can be arbitrary. For best performance use RBW as the VBW.</dd>
<dt>sweepTime  Sweep time in seconds.</dt>
<dd>In sweep mode, this value is how long the device collects data before it
begins processing. Maximum values to be provided should be around
100ms.
In the real-time configuration, this value represents the length of time
data is collected and compounded before returning a sweep. Values for
real-time should be between 16ms-100ms for optimal viewing and use.
In zero span mode this is the length of the returned sweep as a measure
of time. Sweep times for zero span must range between 10us and
100ms. Values outside this range are clamped.</dd>
<dt>rbwType  The possible values for rbwType are BB_NATIVE_RBW and</dt>
<dd>BB_NON_NATIVE_RBW. This choice determines which bandwidth table
is used and how the data is processed. BB_NATIVE_RBW is default and
unchangeable for real-time operation.</dd>
<dt>rejection  The possible values for rejection are BB_NO_SPUR_REJECT,</dt>
<dd>BB_SPUR_REJECT, and BB_BYPASS_RF.</dd>
</dl>
<p>The resolution bandwidth, or RBW, represents the bandwidth of spectral energy represented in each
frequency bin. For example, with an RBW of 10 kHz, the amplitude value for each bin would represent
the total energy from 5 kHz below to 5 kHz above the bin&#8217;s center. For standard bandwidths, the API
uses the 3 dB points to define the RBW.
The video bandwidth, or VBW, is applied after the signal has been converted to frequency domain as
power, voltage, or log units. It is implemented as a simple rectangular window, averaging the amplitude
readings for each frequency bin over several overlapping FFTs. A signal whose amplitude is modulated at
Test Equipment Plus | 17
a much higher frequency than the VBW will be shown as an average, whereas amplitude modulation at
a lower frequency will be shown as a minimum and maximum value.
Native RBWs represent the bandwidths from a single power-of-2 FFT using our sample rate of 80 MSPS
and a high dynamic range window function. Each RBW is half of the previous. Using native RBWs can
give you the lowest possible bandwidth for any given sweep time, and minimizes processing power.
However, scalloping losses of up to 0.8 dB, occurring when a signal falls in between two bins, can cause
problems for some types of measurements.
Non-native RBWs use the traditional 1-3-10 sequence. As of version 1.0.7, non-native bandwidths are
not restricted to the 1-3-10 sequence but can be arbitrary. Programmatically, non-native RBW&#8217;s are
achieved by creating variable sized bandwidth flattop windows.
sweepTime applies to regular sweep mode and real-time mode. If in sweep mode, sweepTime is the
amount of time the device will spend collecting data before processing. Increasing this value is useful for
capturing signals of interest or viewing a more consistent view of the spectrum. Increasing sweepTime
has a very large impact on the amount of resources used by the API due to the increase of data needing
to be stored and the amount of signal processing performed. For this reason, increasing sweepTime also
decreases the rate at which you can acquire sweeps.
In real-time, sweepTime refers to how long data is accumulated before returning a sweep. Ensure you
are capable of retrieving as many sweeps that will be produced by changing this value. For instance,
changing sweepTime to 32ms in real-time mode will return approximately 31 sweeps per second
(1000/32).
Rejection can be used to optimize certain aspects of the signal. Default is BB_NO_SPUR_REJECT, and
should be used in most cases. If you have a steady CW or slowly changing signal, and need to minimize
image and spurious responses from the device, use BB_SPUR_REJECT. If you have a signal between 300
MHz and 3 GHz, need the lowest possible phase noise, and do not need any image rejection,
BB_BYPASS_RF can be used to rewire the front end for lowest phase noise.</p>
<dl class="docutils">
<dt>Native Bandwidths (Hz)      FFT size</dt>
<dd><blockquote class="first">
<div><dl class="docutils">
<dt>10.10e6              16</dt>
<dd>5.050e6             32
2.525e6             64
1.262e6            128</dd>
</dl>
</div></blockquote>
<p>631.2e3              256  Largest Real-Time RBW
315.6e3              512
157.1e3             1024</p>
<blockquote>
<div><p>78.90e3            2048
39.45e3            4096
19.72e3            8192</p>
<blockquote>
<div>9.863e3          16384
4.931e3          32768
2.465e3          65536  Smallest Real-Time RBW
1.232e3         131072</div></blockquote>
</div></blockquote>
<p>616.45            262144
308.22            524288
154.11           1048576
154.11           1048576</p>
<blockquote class="last">
<div><p>77.05           2097152
38.52           4194304
19.26           8388608</p>
<blockquote>
<div>9.63          16777549
4.81          33554432
2.40          67108864
1.204        134217728
0.602        268435456
0.301        536870912</div></blockquote>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureTimeGate">
<tt class="descname">configureTimeGate</tt><big>(</big><em>delay</em>, <em>length</em>, <em>timeout</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureTimeGate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureTimeGate" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureTimeGate(int device, double delay, double length, double timeout);
device  Handle to the device being configured.
delay  The time in seconds, from the trigger to the beginning of the gate
length  The length in seconds, of the gate
timeout  The time in seconds to wait for a trigger. If no trigger is found, the last</p>
<blockquote>
<div>length will be used.</div></blockquote>
<p>Time gates are relative to an external trigger.
Therefore it is necessary to use bbConfigureIO to setup an external trigger.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureTrigger">
<tt class="descname">configureTrigger</tt><big>(</big><em>trigType</em>, <em>edge</em>, <em>level</em>, <em>timeout</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureTrigger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureTrigger" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureTrigger(int device, unsigned int type, unsigned int edge, double level, double timeout);</p>
<p>device  Handle to the device being configured.
type  Specifies the type of trigger to use. Possible values are</p>
<blockquote>
<div>BB_NO_TRIGGER, BB_VIDEO_TRIGGER, BB_EXTERNAL_TRIGGER, and
BB_GPS_PPS_TRIGGER. If an external signal is desired, BNC port 2 must
be configured to accept a trigger (see bbConfigureIO). When
BB_NO_TRIGGER is specified, the other parameters are ignored and this
function sets only trigger type.</div></blockquote>
<dl class="docutils">
<dt>edge  Specifies the edge type of a video trigger. Possible values are</dt>
<dd>BB_TRIGGER_RISING and BB_TRIGGER_FALLING. If you are using a
trigger type other than a video trigger, this value is ignored but must be
specified.</dd>
<dt>level  Level of the video trigger. The units of this value are determined by the</dt>
<dd>demodulation type used when initiating the device. If demodulating
AM, level is in dBm units, if demodulating FM, level is in Hz.</dd>
<dt>timeout  timeout specifies the length of a capture window in seconds. The</dt>
<dd>capture window specifies the length of continuous time you wish to
wait for a trigger. If no trigger is found within the window, the last
sweepTime of data within the data is returned. The capture window
must be greater than sweepTime. If it is not, it will be automatically
adjusted to sweepTime. The timeout/capture window is applicable to
both video and external triggering.</dd>
</dl>
<p>Allows you to configure all zero-span trigger related variables. As with all configure routines, the
changes made here are not reflected until the next initiate.
When a trigger is specified the sweep returned will start approximately 200 microseconds before the
trigger event. This provide a slight view of occurances directly before the event. If no trigger event is
found, the data returned at the end of the timeout period is returned.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.configureWindow">
<tt class="descname">configureWindow</tt><big>(</big><em>window</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.configureWindow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.configureWindow" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbConfigureWindow(int device, unsigned int window);</p>
<p>device  Handle to the device being configured.
window  The possible values for window are BB_NUTALL, BB_BLACKMAN,</p>
<blockquote>
<div>BB_HAMMING, and BB_FLAT_TOP.</div></blockquote>
<p>This changes the windowing function applied to the data before signal processing is performed. In real-
time configuration the window parameter is permanently set to BB_NUTALL. The windows are only
changeable when using the BB_NATIVE_RBW type in bbConfigureSweepCoupling. When using
BB_NON_NATIVE_RBWs, a custom flattop window will be used.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="SignalHound.SignalHound.decodeRawSweep">
<em class="property">static </em><tt class="descname">decodeRawSweep</tt><big>(</big><em>bufPtr</em>, <em>bufLen</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.decodeRawSweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.decodeRawSweep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="SignalHound.SignalHound.devType">
<tt class="descname">devType</tt><em class="property"> = None</em><a class="headerlink" href="#SignalHound.SignalHound.devType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="SignalHound.SignalHound.fastDecodeArray">
<em class="property">static </em><tt class="descname">fastDecodeArray</tt><big>(</big><em>ctBuff</em>, <em>buffLen</em>, <em>dtype</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.fastDecodeArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.fastDecodeArray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.fetchAudio">
<tt class="descname">fetchAudio</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.fetchAudio"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.fetchAudio" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbFetchAudio(int device, float <a href="#id1"><span class="problematic" id="id2">*</span></a>audio);</p>
<p>device  Handle of an initialized device.
audio  Pointer to an array of 4096 32-bit floating point values</p>
<p>If the device is initiated and running in the audio demodulation mode, the function is a blocking call
which returns the next 4096 audio samples. The approximate blocking time for this function is 128 ms if
called again immediately after returning. There is no internal buffering of audio, meaning the audio will
be overwritten if this function is not called in a timely fashion. The audio values are typically -1.0 to 1.0,
representing full-scale audio. In FM mode, the audio values will scale with a change in IF bandwidth.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.fetchRawCorrections">
<tt class="descname">fetchRawCorrections</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.fetchRawCorrections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.fetchRawCorrections" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbFetchRawCorrections(int device, float <a href="#id3"><span class="problematic" id="id4">*</span></a>corrections, int <a href="#id5"><span class="problematic" id="id6">*</span></a>index, double <a href="#id7"><span class="problematic" id="id8">*</span></a>startFreq);</p>
<p>device        Handle of an initialized device.
corrections   32-bit float array of length 2048. Correction values are decibel.
index         Index into the corrections array where the correction data begins.
startFreq      Frequency associated with the correction at index.</p>
<p>When this function returns successfully, the correction array will contain the frequency domain
correction constants for the given bandwidth chosen. The corrections are modified based on
temperature, gain, attenuation, and frequency. If any of these change, a new correction array should be
requested. The correction array will only be generated again on a new bbInitiate().
The correction arrays and returned values differ slightly depending on the 7 or 20 MHz bandwidth
chosen. Each one is described in depth below.</p>
<p>The correction array represents 40 MHz of bandwidth where frequencies outside the requested 20 MHz
are zeroed out. The first non-zero sample begins at corrections[index]. The frequency at this index is
startFreq. The bin size of each index is implied through 40 MHz divided by the length of the array,
(40.0e6 / 2048) = 19531.25 Hz. If an Fourier transform is applied on the IF data, the correction values
will line up with the usable 20 MHz bandwdith.
7MHz
The correction array represents 10 Mhz of bandwdith where the usable 7 MHz is centered and all values
outside the usable 7 MHz is zeroed. The index returned is the first non zero sample in the array. The
startFreq returned is the frequency of the first sample in the array, corrections[0]. Every other sample’s
frequency can be determined with the bin size. The bin size for this array is (10.0e6 / 2048) = 4882.8125
Hz. If a complex Fourier Transform is applied to the IQ data, the correction values will line up with the
usable 7 MHz bandwidth.
Tips
Time domain corrections of the signal’s amplitude require two steps. First, an inverse Fourier Transform
must be performed on the entire correction array (including zero’ed portions). This results in a 4096
sample kernel. Second, the kernel is used in convolution with the time domain data. If a larger/smaller
kernel is desired, interpolate/extrapolate the correction array while it is in the frequency domain to the
desired length. Lengths which are powers of two are suggested.
Frequency domain correction of the signal’s amplitude requires you to first transform the raw data into
the frequency domain. Performing an Fourier transform on the incoming data will yeild a frequency
domain array that will align with the correction array. You can index the Transform results using the
index returned from this function if you wish or apply the whole array. Remember that the corrections
are in dB. If larger Transform sizes are desired, you can interpolate the correction array to the desired
size. (Be aware! This will change the index of the first non-zero correction, but the results of the FFT will
still align the with usable 20 MHz)</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.fetchRawSweep">
<tt class="descname">fetchRawSweep</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.fetchRawSweep"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.fetchRawSweep" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbFetchRawSweep(int device, short <a href="#id9"><span class="problematic" id="id10">*</span></a>buffer);</p>
<p>device  Handle of an initialized device.
buffer  Pointer to an array of signed short integers</p>
<p>This function is used to collect a single sweep for a device configured in raw sweep mode. The length of
the buffer provided is determined by the settings used to configure the device for raw sweep mode. This
length can be determined using the equation.</p>
<blockquote>
<div>Buffer-Length = 18688 * ppf * steps</div></blockquote>
<p>If the function returns successfully the array will contain a full sweep. The shorts will</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.fetchTrace">
<tt class="descname">fetchTrace</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.fetchTrace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.fetchTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbFetchTrace(int device, int arraySize, double <a href="#id11"><span class="problematic" id="id12">*</span></a>min, double <a href="#id13"><span class="problematic" id="id14">*</span></a>max);
device  Handle of an initialized device.
arraySize  A provided arraySize. This value must be equal to or greater than the
traceSize value returned from bbQueryTraceInfo.</p>
<blockquote>
<div>min  Pointer to a double buffer, whose length is equal to or greater than</div></blockquote>
<dl class="docutils">
<dt>traceSize returned from bbQueryTraceInfo.</dt>
<dd>max  Pointer to a double buffer, whose length is equal to or greater than</dd>
</dl>
<p>traceSize returned from bbQueryTraceInfo.</p>
<p>Returns a minimum and maximum array of values relating to the current mode of operation. If the
detectorType provided in bbConfigureAcquisition is BB_AVERAGE, the array will be populated with the
same values. Element zero of each array corresponds to the startFreq returned from bbQueryTraceInfo.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.forceClose">
<tt class="descname">forceClose</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.forceClose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.forceClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getAPIVersion">
<tt class="descname">getAPIVersion</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getAPIVersion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getAPIVersion" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API const char* bbGetAPIVersion();</p>
<p>The returned string is of the form
major.minor.revision
Ascii periods (“.”) separate positive integers. Major/Minor/Revision are
not gauranteed to be a single decimal digit. The string is null
terminated. An example string is below ..
[ ‘1’ | ‘.’ | ‘2’ | ‘.’ | ‘1’ | ‘1’ | ‘’ ] = “1.2.11”</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getCurrentAcquisitionSettings">
<tt class="descname">getCurrentAcquisitionSettings</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getCurrentAcquisitionSettings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getCurrentAcquisitionSettings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getDeviceDiagnostics">
<tt class="descname">getDeviceDiagnostics</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getDeviceDiagnostics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getDeviceDiagnostics" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbGetDeviceDiagnostics(int device, float <a href="#id15"><span class="problematic" id="id16">*</span></a>temperature, float <a href="#id17"><span class="problematic" id="id18">*</span></a>voltage1_8, float <a href="#id19"><span class="problematic" id="id20">*</span></a>voltage1_2, float <a href="#id21"><span class="problematic" id="id22">*</span></a>voltageUSB, float <a href="#id23"><span class="problematic" id="id24">*</span></a>currentUSB);</p>
<dl class="docutils">
<dt>temperature  Pointer to 32bit float. If the function is successful temperature will point</dt>
<dd>to the current internal device temperature, in degrees Celsius. See
&#8220;bbSelfCal&#8221; for an explanation on why you need to monitor the device
temperature.</dd>
</dl>
<p>voltageUSB  USB operating voltage, in volts. Acceptable ranges are 4.40 to 5.25 V.
currentUSB  USB current draw, in mA. Acceptable ranges are 800 - 1000 mA</p>
<p>Pass NULL to any parameter you do not wish to query.
The device temperature is updated in the API after each sweep is retrieved. The temperature is returned
in Celsius and has a resolution of 1/8 th of a degree. A temperature above 70 ° C or below 0 ° C indicates
your device is operating outside of its normal operating temperature, and may cause readings to be out
of spec, and may damage the device.
A USB voltage of below 4.4V may cause readings to be out of spec. Check your cable for damage and
USB connectors for damage or oxidation.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getDeviceType">
<tt class="descname">getDeviceType</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getDeviceType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getDeviceType" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbGetDeviceType(int device, int <a href="#id25"><span class="problematic" id="id26">*</span></a>type);</p>
<p>This function may be called only after the device has been opened. If the device successfully opened,
type will contain the model type of the device pointed to by handle.
Possible values for type are BB_DEVICE_NONE, BB_DEVICE_BB60A, BB_DEVICE_BB124. These values can
be found in the bb_api header file</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getErrorString">
<tt class="descname">getErrorString</tt><big>(</big><em>errCode</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getErrorString"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getErrorString" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API const char* bbGetErrorString(bbStatus status);</p>
<p>Produce an ascii string representation of a given status code. Useful for debugging.
Probably not really needed, since I&#8217;m doing error decoding locally in each function.</p>
<p>This /should/ be of type bbStatus. bbStatus is an enum with hard-coded values, so I&#8217;m being lazy, and just using
an int. It works well enough.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getFirmwareVersion">
<tt class="descname">getFirmwareVersion</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getFirmwareVersion"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getFirmwareVersion" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbGetFirmwareVersion(int device, int <a href="#id27"><span class="problematic" id="id28">*</span></a>version);</p>
<p>Use this function to determine which version of firmware is associated with the specified device.</p>
</dd></dl>

<dl class="classmethod">
<dt id="SignalHound.SignalHound.getRawSweepTrig_size">
<em class="property">classmethod </em><tt class="descname">getRawSweepTrig_size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getRawSweepTrig_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getRawSweepTrig_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="SignalHound.SignalHound.getRawSweep_s_size">
<em class="property">classmethod </em><tt class="descname">getRawSweep_s_size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getRawSweep_s_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getRawSweep_s_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="SignalHound.SignalHound.getRawSweep_size">
<em class="property">classmethod </em><tt class="descname">getRawSweep_size</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getRawSweep_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getRawSweep_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.getSerialNumber">
<tt class="descname">getSerialNumber</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.getSerialNumber"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.getSerialNumber" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbGetSerialNumber(int device, unsigned int <a href="#id29"><span class="problematic" id="id30">*</span></a>sid);</p>
<p>This function may be called only after the device has been opened. The serial number returned should
match the number on the case.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.initiate">
<tt class="descname">initiate</tt><big>(</big><em>mode</em>, <em>flag</em>, <em>gps_timestamp=False</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.initiate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.initiate" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbInitiate(int device, unsigned int mode, unsigned int flag);</p>
<p>device  Handle to the device being configured.
mode  The possible values for mode are BB_SWEEPING, BB_REAL_TIME,</p>
<blockquote>
<div>BB_ZERO_SPAN, BB_TIME_GATE, BB_RAW_SWEEP,
BB_RAW_SWEEP_LOOP and BB_AUDIO_DEMOD.</div></blockquote>
<dl class="docutils">
<dt>flag  The default value is zero.</dt>
<dd>If mode equals BB_ZERO_SPAN, flag can be used to denote the type of
modulation performed on the incoming signal. BB_DEMOD_AM and
BB_DEMOD_FM are the two options.
Flag can be used to inform the API to time
stamp data using an external GPS reciever. Mask the bandwidth flag (‘|’
in C) with BB_TIME_STAMP to achieve this. See Appendix:Using a GPS
Receiver to Time-Stamp Data for information on how to set this up.</dd>
</dl>
<p>bbInitiate configures the device into a state determined by the mode parameter. For more information
regarding operating states, refer to the Theory of Operation and Modes of Operation sections. This
function calls bbAbort before attempting to reconfigure. It should be noted, if an error is returned, any
past operating state will no longer be active.
Pay special attention to the bbInvalidParameterErr description below</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.openDevice">
<tt class="descname">openDevice</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.openDevice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.openDevice" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.preset">
<tt class="descname">preset</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.preset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.preset" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbPreset(int device);</p>
<p>This function exists to invoke a hard reset of the device. This will function similarly to a power
cycle(unplug/re-plug the device). This might be useful if the device has entered an undesirable or
unrecoverable state. Often the device might become unrecoverable if a program closed unexpectedly,
not allowing the device to close properly. This function might allow the software to perform the reset
rather than ask the user perform a power cycle.</p>
<p>Viewing the traces returned is often the best way to determine if the device is operating normally. To
utilize this function, the device must be open. Calling this function will trigger a reset which happens
after 2 seconds. Within this time you must call bbCloseDevice to free any remaining resources and
release the device serial number from the open device list. From the time of the bbPreset call, we
suggest 3 to more seconds of wait time before attempting to re-open the device.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.queryDeviceDiagnostics">
<tt class="descname">queryDeviceDiagnostics</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.queryDeviceDiagnostics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.queryDeviceDiagnostics" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.queryStreamInfo">
<tt class="descname">queryStreamInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.queryStreamInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.queryStreamInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.queryStreamingCenter">
<tt class="descname">queryStreamingCenter</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.queryStreamingCenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.queryStreamingCenter" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbQueryStreamingCenter(int device, double <a href="#id31"><span class="problematic" id="id32">*</span></a>center);
device  Handle of an initialized device.
center  Pointer to a double which will receive the absolute center frequency of</p>
<blockquote>
<div>the streaming device.</div></blockquote>
<p>The function retrieves the center frequency of the 20 MHz IF bandwidth of a device currently initialized
in raw pipe mode. The center returned is representative of ¼ of the IF sample rate. The 20 MHz of usable
bandwidth is centered on this frequency.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.queryTimestamp">
<tt class="descname">queryTimestamp</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.queryTimestamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.queryTimestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbQueryTimestamp(int device, unsigned int <a href="#id33"><span class="problematic" id="id34">*</span></a>seconds, unsigned int <a href="#id35"><span class="problematic" id="id36">*</span></a>nanoseconds);</p>
<p>device  Handle of an initialized device.
seconds  Seconds since midnight (00:00:00), January 1, 1970, coordinated</p>
<blockquote>
<div>universal time(UTC).</div></blockquote>
<p>nanoseconds  nanoseconds between seconds and seconds + 1</p>
<p>This function is used in conjunction with bbSyncCPUtoGPS and a GPS device to retrieve an absolute time
for a data packet in raw pipe mode. This function returns an absolute time for the last packet retrieved
from bbFetchRaw. See the Appendix:Code Examples for information on how to setup and interpret the
time information.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.queryTraceInfo">
<tt class="descname">queryTraceInfo</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.queryTraceInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.queryTraceInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbQueryTraceInfo(int device, unsigned int <a href="#id37"><span class="problematic" id="id38">*</span></a>traceLen, double <a href="#id39"><span class="problematic" id="id40">*</span></a>binSize, double <a href="#id41"><span class="problematic" id="id42">*</span></a>start);</p>
<p>device  Handle of an initialized device.
traceLen  A pointer to an unsigned int. If the function returns successfully</p>
<blockquote>
<div>traceLen will contain the size of arrays returned by bbFetchTrace.</div></blockquote>
<dl class="docutils">
<dt>binSize  A pointer to a 64bit floating point variable. If the function returns</dt>
<dd>successfully, binSize will contain the frequency difference between two
sequential bins in a returned sweep. In Zero-Span mode, binSize refers
to the difference between sequential samples in seconds.</dd>
<dt>start  A pointer to a 64bit floating point variable. If the function returns</dt>
<dd>successfully, start will contain the frequency of the first bin in a
returned sweep. In Zero-Span mode, start represents the exact center
frequency used by the API.</dd>
</dl>
<p>This function should be called to determine sweep characteristics after a device has been configured
and initiated. For zero-span mode, startFreq and binSize will refer to the time domain values. In zero-
span mode startFreq will always be zero, and binSize will be equal to sweepTime/traceSize.</p>
<p>Note: Calling while in BB_RAW_PIPE mode will produce a bbDeviceNotConfiguredErr</p>
</dd></dl>

<dl class="attribute">
<dt id="SignalHound.SignalHound.rawDataArrSize">
<tt class="descname">rawDataArrSize</tt><em class="property"> = 299008</em><a class="headerlink" href="#SignalHound.SignalHound.rawDataArrSize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="SignalHound.SignalHound.rawSweepTriggerArraySize">
<tt class="descname">rawSweepTriggerArraySize</tt><em class="property"> = 68</em><a class="headerlink" href="#SignalHound.SignalHound.rawSweepTriggerArraySize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.selfCal">
<tt class="descname">selfCal</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.selfCal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.selfCal" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbSelfCal(int device);</p>
<p>This function causes the device to recalibrate itself to adjust for internal device temperature changes,
generating an amplitude correction array as a function of IF frequency. This function will explicitly call
bbAbort() to suspend all device operations before performing the calibration, and will return the device
in an idle state and configured as if it was just opened. The state of the device should not be assumed,
and should be fully reconfigured after a self-calibration.
Temperature changes of 2 degrees Celsius or more have been shown to measurably alter the
shape/amplitude of the IF. We suggest using bbQueryDiagnostics to monitor the device’s temperature
and perform self-calibrations when needed. Amplitude measurements are not guaranteed to be
accurate otherwise, and large temperature changes (10 ° C or more) may result in adding a dB or more of
error.
Because this is a streaming device, we have decided to leave the programmer in full control of when the
device in calibrated. The device is calibrated once upon opening the device through bbOpenDevice and is
the responsibility of the programmer after that.
Note:
After calling this function, the device returns to the default state. Currently the API does not retain state
prior to the calling of bbSelfCal(). Fully reconfiguring the device will be necessary.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.startRawSweepLoop">
<tt class="descname">startRawSweepLoop</tt><big>(</big><em>callbackFunc</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.startRawSweepLoop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.startRawSweepLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbStartRawSweepLoop(int device, void(<a href="#id43"><span class="problematic" id="id44">*</span></a>sweep_callback)(short <a href="#id45"><span class="problematic" id="id46">*</span></a>buffer, int len));</p>
<p>device  Handle of an initialized device.
sweep_callback  Pointer to a C function. Used as a callback to notify the user of</p>
<blockquote>
<div>completed sweeps.</div></blockquote>
<p>This function can be called after being configured and initiated in RAW_SWEEP_LOOP mode. The device
begins sweeping on the first call to this function after the device has been initiated. It is possible to call
this function multiple times per initiate to change the function call back used.
If this function returns successfully, the device begins sweeping immediately. The function provided is
set as the callback function used when a sweep is completed. sweep_callback is called once per sweep
completion. The function passes two parameters, a pointer to the buffer of data for the sweep, and the
length of the buffer.
The data buffer will not be overwritten when in the function body of sweep_callback. The API will
maintain a circular list of buffers to store sweeps in. The API will store up to ¼ to ½ seconds worth of
sweeps depending on parameters. If the function body of sweep_callback exceeds this amount of time,
it is possible for the API to need to move ahead and skip over the buffer the user is still accessing. This
will cause a loss of data. It is recommended the function body of sweep_callback is short, preferably
simply copying the data from buffer into your own data structure. This ensures you receive every sweep
and make your own decisions on when to drop/ignore sweeps.
The sweep_callback function is not called in the main thread of execution. It is called once per sweep,
which can result in the function being called anywhere from 3-250 milliseconds. It is the responsibility of
the user to not index the buffer out of range. The buffer contents can be modified by the user only
during the function body of sweep_callback, once the function returns, the API is free to overwrite the
contents. Modifying the contents of the buffer not in the function body of sweep_callback is undefined.
The user should not attempt to manage any of the memory provided through the buffer pointers.
The device sweeps indefinitely until bbAbort or bbCloseDevice is called. When operation is suspended
via bbAbort, the device must be reconfigured and initiated again before calling this function.</p>
</dd></dl>

<dl class="method">
<dt id="SignalHound.SignalHound.syncCPUtoGPS">
<tt class="descname">syncCPUtoGPS</tt><big>(</big><em>comPort</em>, <em>baudRate</em><big>)</big><a class="reference internal" href="_modules/SignalHound.html#SignalHound.syncCPUtoGPS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#SignalHound.SignalHound.syncCPUtoGPS" title="Permalink to this definition">¶</a></dt>
<dd><p>BB_API bbStatus bbSyncCPUtoGPS(int comPort, int baudRate);</p>
<p>comPort  Com port number for the NMEA data output from the GPS reciever.
baudRate  Baud Rate of the Com port</p>
<p>The connection to the COM port is only established for the duration of this function. It is closed when
the function returns. Call this function once before using a GPS PPS signal to time-stamp RF data. The
synchronization will remain valid until the CPU clock drifts more than ¼ second, typically several hours,
and will re-synchronize continually while streaming data using a PPS trigger input.
This function calculates the offset between your CPU clock time and the GPS clock time to within a few
milliseconds, and stores this value for time-stamping RF data using the GPS PPS trigger. This function
ignores time zone, limiting the calculated offset to +/- 30 minutes. It was tested using an FTS 500 from
Connor Winfield at 38.4 kbaud. It uses the “$GPRMC” string, so you must set up your GPS to output this
string.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">PySignalHound 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Connor Wolf.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>